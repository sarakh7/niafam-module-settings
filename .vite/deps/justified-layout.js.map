{
  "version": 3,
  "sources": ["../../node_modules/justified-layout/lib/row.js", "../../node_modules/justified-layout/lib/index.js"],
  "sourcesContent": ["/*!\n * Copyright 2019 SmugMug, Inc.\n * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.\n * @license\n */\n\n/**\n * Row\n * Wrapper for each row in a justified layout.\n * Stores relevant values and provides methods for calculating layout of individual rows.\n *\n * @param {Object} layoutConfig - The same as that passed\n * @param {Object} Initialization parameters. The following are all required:\n * @param params.top {Number} Top of row, relative to container\n * @param params.left {Number} Left side of row relative to container (equal to container left padding)\n * @param params.width {Number} Width of row, not including container padding\n * @param params.spacing {Number} Horizontal spacing between items\n * @param params.targetRowHeight {Number} Layout algorithm will aim for this row height\n * @param params.targetRowHeightTolerance {Number} Row heights may vary +/- (`targetRowHeight` x `targetRowHeightTolerance`)\n * @param params.edgeCaseMinRowHeight {Number} Absolute minimum row height for edge cases that cannot be resolved within tolerance.\n * @param params.edgeCaseMaxRowHeight {Number} Absolute maximum row height for edge cases that cannot be resolved within tolerance.\n * @param params.isBreakoutRow {Boolean} Is this row in particular one of those breakout rows? Always false if it's not that kind of photo list\n * @param params.widowLayoutStyle {String} If widows are visible, how should they be laid out?\n * @constructor\n */\n\nvar Row = module.exports = function (params) {\n\n\t// Top of row, relative to container\n\tthis.top = params.top;\n\n\t// Left side of row relative to container (equal to container left padding)\n\tthis.left = params.left;\n\n\t// Width of row, not including container padding\n\tthis.width = params.width;\n\n\t// Horizontal spacing between items\n\tthis.spacing = params.spacing;\n\n\t// Row height calculation values\n\tthis.targetRowHeight = params.targetRowHeight;\n\tthis.targetRowHeightTolerance = params.targetRowHeightTolerance;\n\tthis.minAspectRatio = this.width / params.targetRowHeight * (1 - params.targetRowHeightTolerance);\n\tthis.maxAspectRatio = this.width / params.targetRowHeight * (1 + params.targetRowHeightTolerance);\n\n\t// Edge case row height minimum/maximum\n\tthis.edgeCaseMinRowHeight = params.edgeCaseMinRowHeight;\n\tthis.edgeCaseMaxRowHeight = params.edgeCaseMaxRowHeight;\n\n\t// Widow layout direction\n\tthis.widowLayoutStyle = params.widowLayoutStyle;\n\n\t// Full width breakout rows\n\tthis.isBreakoutRow = params.isBreakoutRow;\n\n\t// Store layout data for each item in row\n\tthis.items = [];\n\n\t// Height remains at 0 until it's been calculated\n\tthis.height = 0;\n\n};\n\nRow.prototype = {\n\n\t/**\n\t * Attempt to add a single item to the row.\n\t * This is the heart of the justified algorithm.\n\t * This method is direction-agnostic; it deals only with sizes, not positions.\n\t *\n\t * If the item fits in the row, without pushing row height beyond min/max tolerance,\n\t * the item is added and the method returns true.\n\t *\n\t * If the item leaves row height too high, there may be room to scale it down and add another item.\n\t * In this case, the item is added and the method returns true, but the row is incomplete.\n\t *\n\t * If the item leaves row height too short, there are too many items to fit within tolerance.\n\t * The method will either accept or reject the new item, favoring the resulting row height closest to within tolerance.\n\t * If the item is rejected, left/right padding will be required to fit the row height within tolerance;\n\t * if the item is accepted, top/bottom cropping will be required to fit the row height within tolerance.\n\t *\n\t * @method addItem\n\t * @param itemData {Object} Item layout data, containing item aspect ratio.\n\t * @return {Boolean} True if successfully added; false if rejected.\n\t */\n\n\taddItem: function (itemData) {\n\n\t\tvar newItems = this.items.concat(itemData),\n\t\t\t// Calculate aspect ratios for items only; exclude spacing\n\t\t\trowWidthWithoutSpacing = this.width - (newItems.length - 1) * this.spacing,\n\t\t\tnewAspectRatio = newItems.reduce(function (sum, item) {\n\t\t\t\treturn sum + item.aspectRatio;\n\t\t\t}, 0),\n\t\t\ttargetAspectRatio = rowWidthWithoutSpacing / this.targetRowHeight,\n\t\t\tpreviousRowWidthWithoutSpacing,\n\t\t\tpreviousAspectRatio,\n\t\t\tpreviousTargetAspectRatio;\n\n\t\t// Handle big full-width breakout photos if we're doing them\n\t\tif (this.isBreakoutRow) {\n\t\t\t// Only do it if there's no other items in this row\n\t\t\tif (this.items.length === 0) {\n\t\t\t\t// Only go full width if this photo is a square or landscape\n\t\t\t\tif (itemData.aspectRatio >= 1) {\n\t\t\t\t\t// Close out the row with a full width photo\n\t\t\t\t\tthis.items.push(itemData);\n\t\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / itemData.aspectRatio, 'justify');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newAspectRatio < this.minAspectRatio) {\n\n\t\t\t// New aspect ratio is too narrow / scaled row height is too tall.\n\t\t\t// Accept this item and leave row open for more items.\n\n\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\treturn true;\n\n\t\t} else if (newAspectRatio > this.maxAspectRatio) {\n\n\t\t\t// New aspect ratio is too wide / scaled row height will be too short.\n\t\t\t// Accept item if the resulting aspect ratio is closer to target than it would be without the item.\n\t\t\t// NOTE: Any row that falls into this block will require cropping/padding on individual items.\n\n\t\t\tif (this.items.length === 0) {\n\n\t\t\t\t// When there are no existing items, force acceptance of the new item and complete the layout.\n\t\t\t\t// This is the pano special case.\n\t\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// Calculate width/aspect ratio for row before adding new item\n\t\t\tpreviousRowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing;\n\t\t\tpreviousAspectRatio = this.items.reduce(function (sum, item) {\n\t\t\t\treturn sum + item.aspectRatio;\n\t\t\t}, 0);\n\t\t\tpreviousTargetAspectRatio = previousRowWidthWithoutSpacing / this.targetRowHeight;\n\n\t\t\tif (Math.abs(newAspectRatio - targetAspectRatio) > Math.abs(previousAspectRatio - previousTargetAspectRatio)) {\n\n\t\t\t\t// Row with new item is us farther away from target than row without; complete layout and reject item.\n\t\t\t\tthis.completeLayout(previousRowWidthWithoutSpacing / previousAspectRatio, 'justify');\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Row with new item is us closer to target than row without;\n\t\t\t\t// accept the new item and complete the row layout.\n\t\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// New aspect ratio / scaled row height is within tolerance;\n\t\t\t// accept the new item and complete the row layout.\n\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\treturn true;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Check if a row has completed its layout.\n\t *\n\t * @method isLayoutComplete\n\t * @return {Boolean} True if complete; false if not.\n\t */\n\n\tisLayoutComplete: function () {\n\t\treturn this.height > 0;\n\t},\n\n\t/**\n\t * Set row height and compute item geometry from that height.\n\t * Will justify items within the row unless instructed not to.\n\t *\n\t * @method completeLayout\n\t * @param newHeight {Number} Set row height to this value.\n\t * @param widowLayoutStyle {String} How should widows display? Supported: left | justify | center\n\t */\n\n\tcompleteLayout: function (newHeight, widowLayoutStyle) {\n\n\t\tvar itemWidthSum = this.left,\n\t\t\trowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,\n\t\t\tclampedToNativeRatio,\n\t\t\tclampedHeight,\n\t\t\terrorWidthPerItem,\n\t\t\troundedCumulativeErrors,\n\t\t\tsingleItemGeometry,\n\t\t\tcenterOffset;\n\n\t\t// Justify unless explicitly specified otherwise.\n\t\tif (typeof widowLayoutStyle === 'undefined' || ['justify', 'center', 'left'].indexOf(widowLayoutStyle) < 0) {\n\t\t\twidowLayoutStyle = 'left';\n\t\t}\n\n\t\t// Clamp row height to edge case minimum/maximum.\n\t\tclampedHeight = Math.max(this.edgeCaseMinRowHeight, Math.min(newHeight, this.edgeCaseMaxRowHeight));\n\n\t\tif (newHeight !== clampedHeight) {\n\n\t\t\t// If row height was clamped, the resulting row/item aspect ratio will be off,\n\t\t\t// so force it to fit the width (recalculate aspectRatio to match clamped height).\n\t\t\t// NOTE: this will result in cropping/padding commensurate to the amount of clamping.\n\t\t\tthis.height = clampedHeight;\n\t\t\tclampedToNativeRatio = (rowWidthWithoutSpacing / clampedHeight) / (rowWidthWithoutSpacing / newHeight);\n\n\t\t} else {\n\n\t\t\t// If not clamped, leave ratio at 1.0.\n\t\t\tthis.height = newHeight;\n\t\t\tclampedToNativeRatio = 1.0;\n\n\t\t}\n\n\t\t// Compute item geometry based on newHeight.\n\t\tthis.items.forEach(function (item) {\n\n\t\t\titem.top = this.top;\n\t\t\titem.width = item.aspectRatio * this.height * clampedToNativeRatio;\n\t\t\titem.height = this.height;\n\n\t\t\t// Left-to-right.\n\t\t\t// TODO right to left\n\t\t\t// item.left = this.width - itemWidthSum - item.width;\n\t\t\titem.left = itemWidthSum;\n\n\t\t\t// Increment width.\n\t\t\titemWidthSum += item.width + this.spacing;\n\n\t\t}, this);\n\n\t\t// If specified, ensure items fill row and distribute error\n\t\t// caused by rounding width and height across all items.\n\t\tif (widowLayoutStyle === 'justify') {\n\n\t\t\titemWidthSum -= (this.spacing + this.left);\n\n\t\t\terrorWidthPerItem = (itemWidthSum - this.width) / this.items.length;\n\t\t\troundedCumulativeErrors = this.items.map(function (item, i) {\n\t\t\t\treturn Math.round((i + 1) * errorWidthPerItem);\n\t\t\t});\n\n\n\t\t\tif (this.items.length === 1) {\n\n\t\t\t\t// For rows with only one item, adjust item width to fill row.\n\t\t\t\tsingleItemGeometry = this.items[0];\n\t\t\t\tsingleItemGeometry.width -= Math.round(errorWidthPerItem);\n\n\t\t\t} else {\n\n\t\t\t\t// For rows with multiple items, adjust item width and shift items to fill the row,\n\t\t\t\t// while maintaining equal spacing between items in the row.\n\t\t\t\tthis.items.forEach(function (item, i) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\titem.left -= roundedCumulativeErrors[i - 1];\n\t\t\t\t\t\titem.width -= (roundedCumulativeErrors[i] - roundedCumulativeErrors[i - 1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.width -= roundedCumulativeErrors[i];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t} else if (widowLayoutStyle === 'center') {\n\n\t\t\t// Center widows\n\t\t\tcenterOffset = (this.width - itemWidthSum) / 2;\n\n\t\t\tthis.items.forEach(function (item) {\n\t\t\t\titem.left += centerOffset + this.spacing;\n\t\t\t}, this);\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Force completion of row layout with current items.\n\t *\n\t * @method forceComplete\n\t * @param fitToWidth {Boolean} Stretch current items to fill the row width.\n\t *                             This will likely result in padding.\n\t * @param fitToWidth {Number}\n\t */\n\n\tforceComplete: function (fitToWidth, rowHeight) {\n\n\t\t// TODO Handle fitting to width\n\t\t// var rowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,\n\t\t// \tcurrentAspectRatio = this.items.reduce(function (sum, item) {\n\t\t// \t\treturn sum + item.aspectRatio;\n\t\t// \t}, 0);\n\n\t\tif (typeof rowHeight === 'number') {\n\n\t\t\tthis.completeLayout(rowHeight, this.widowLayoutStyle);\n\n\t\t} else {\n\n\t\t\t// Complete using target row height.\n\t\t\tthis.completeLayout(this.targetRowHeight, this.widowLayoutStyle);\n\t\t}\n\n\t},\n\n\t/**\n\t * Return layout data for items within row.\n\t * Note: returns actual list, not a copy.\n\t *\n\t * @method getItems\n\t * @return Layout data for items within row.\n\t */\n\n\tgetItems: function () {\n\t\treturn this.items;\n\t}\n\n};\n", "/*!\n * Copyright 2019 SmugMug, Inc.\n * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.\n * @license\n */\n\n'use strict';\n\nvar Row = require('./row');\n\n/**\n * Create a new, empty row.\n *\n * @method createNewRow\n * @param layoutConfig {Object} The layout configuration\n * @param layoutData {Object} The current state of the layout\n * @return A new, empty row of the type specified by this layout.\n */\n\nfunction createNewRow(layoutConfig, layoutData) {\n\n\tvar isBreakoutRow;\n\n\t// Work out if this is a full width breakout row\n\tif (layoutConfig.fullWidthBreakoutRowCadence !== false) {\n\t\tif (((layoutData._rows.length + 1) % layoutConfig.fullWidthBreakoutRowCadence) === 0) {\n\t\t\tisBreakoutRow = true;\n\t\t}\n\t}\n\n\treturn new Row({\n\t\ttop: layoutData._containerHeight,\n\t\tleft: layoutConfig.containerPadding.left,\n\t\twidth: layoutConfig.containerWidth - layoutConfig.containerPadding.left - layoutConfig.containerPadding.right,\n\t\tspacing: layoutConfig.boxSpacing.horizontal,\n\t\ttargetRowHeight: layoutConfig.targetRowHeight,\n\t\ttargetRowHeightTolerance: layoutConfig.targetRowHeightTolerance,\n\t\tedgeCaseMinRowHeight: 0.5 * layoutConfig.targetRowHeight,\n\t\tedgeCaseMaxRowHeight: 2 * layoutConfig.targetRowHeight,\n\t\trightToLeft: false,\n\t\tisBreakoutRow: isBreakoutRow,\n\t\twidowLayoutStyle: layoutConfig.widowLayoutStyle\n\t});\n}\n\n/**\n * Add a completed row to the layout.\n * Note: the row must have already been completed.\n *\n * @method addRow\n * @param layoutConfig {Object} The layout configuration\n * @param layoutData {Object} The current state of the layout\n * @param row {Row} The row to add.\n * @return {Array} Each item added to the row.\n */\n\nfunction addRow(layoutConfig, layoutData, row) {\n\n\tlayoutData._rows.push(row);\n\tlayoutData._layoutItems = layoutData._layoutItems.concat(row.getItems());\n\n\t// Increment the container height\n\tlayoutData._containerHeight += row.height + layoutConfig.boxSpacing.vertical;\n\n\treturn row.items;\n}\n\n/**\n * Calculate the current layout for all items in the list that require layout.\n * \"Layout\" means geometry: position within container and size\n *\n * @method computeLayout\n * @param layoutConfig {Object} The layout configuration\n * @param layoutData {Object} The current state of the layout\n * @param itemLayoutData {Array} Array of items to lay out, with data required to lay out each item\n * @return {Object} The newly-calculated layout, containing the new container height, and lists of layout items\n */\n\nfunction computeLayout(layoutConfig, layoutData, itemLayoutData) {\n\n\tvar laidOutItems = [],\n\t\titemAdded,\n\t\tcurrentRow,\n\t\tnextToLastRowHeight;\n\n\t// Apply forced aspect ratio if specified, and set a flag.\n\tif (layoutConfig.forceAspectRatio) {\n\t\titemLayoutData.forEach(function (itemData) {\n\t\t\titemData.forcedAspectRatio = true;\n\t\t\titemData.aspectRatio = layoutConfig.forceAspectRatio;\n\t\t});\n\t}\n\n\t// Loop through the items\n\titemLayoutData.some(function (itemData, i) {\n\n\t\tif (isNaN(itemData.aspectRatio)) {\n\t\t\tthrow new Error(\"Item \" + i + \" has an invalid aspect ratio\");\n\t\t}\n\n\t\t// If not currently building up a row, make a new one.\n\t\tif (!currentRow) {\n\t\t\tcurrentRow = createNewRow(layoutConfig, layoutData);\n\t\t}\n\n\t\t// Attempt to add item to the current row.\n\t\titemAdded = currentRow.addItem(itemData);\n\n\t\tif (currentRow.isLayoutComplete()) {\n\n\t\t\t// Row is filled; add it and start a new one\n\t\t\tlaidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));\n\n\t\t\tif (layoutData._rows.length >= layoutConfig.maxNumRows) {\n\t\t\t\tcurrentRow = null;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcurrentRow = createNewRow(layoutConfig, layoutData);\n\n\t\t\t// Item was rejected; add it to its own row\n\t\t\tif (!itemAdded) {\n\n\t\t\t\titemAdded = currentRow.addItem(itemData);\n\n\t\t\t\tif (currentRow.isLayoutComplete()) {\n\n\t\t\t\t\t// If the rejected item fills a row on its own, add the row and start another new one\n\t\t\t\t\tlaidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));\n\t\t\t\t\tif (layoutData._rows.length >= layoutConfig.maxNumRows) {\n\t\t\t\t\t\tcurrentRow = null;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentRow = createNewRow(layoutConfig, layoutData);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\n\t// Handle any leftover content (orphans) depending on where they lie\n\t// in this layout update, and in the total content set.\n\tif (currentRow && currentRow.getItems().length && layoutConfig.showWidows) {\n\n\t\t// Last page of all content or orphan suppression is suppressed; lay out orphans.\n\t\tif (layoutData._rows.length) {\n\n\t\t\t// Only Match previous row's height if it exists and it isn't a breakout row\n\t\t\tif (layoutData._rows[layoutData._rows.length - 1].isBreakoutRow) {\n\t\t\t\tnextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].targetRowHeight;\n\t\t\t} else {\n\t\t\t\tnextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].height;\n\t\t\t}\n\n\t\t\tcurrentRow.forceComplete(false, nextToLastRowHeight);\n\n\t\t} else {\n\n\t\t\t// ...else use target height if there is no other row height to reference.\n\t\t\tcurrentRow.forceComplete(false);\n\n\t\t}\n\n\t\tlaidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));\n\t\tlayoutConfig._widowCount = currentRow.getItems().length;\n\n\t}\n\n\t// We need to clean up the bottom container padding\n\t// First remove the height added for box spacing\n\tlayoutData._containerHeight = layoutData._containerHeight - layoutConfig.boxSpacing.vertical;\n\t// Then add our bottom container padding\n\tlayoutData._containerHeight = layoutData._containerHeight + layoutConfig.containerPadding.bottom;\n\n\treturn {\n\t\tcontainerHeight: layoutData._containerHeight,\n\t\twidowCount: layoutConfig._widowCount,\n\t\tboxes: layoutData._layoutItems\n\t};\n\n}\n\n/**\n * Takes in a bunch of box data and config. Returns\n * geometry to lay them out in a justified view.\n *\n * @method covertSizesToAspectRatios\n * @param sizes {Array} Array of objects with widths and heights\n * @return {Array} A list of aspect ratios\n */\n\nmodule.exports = function (input, config) {\n\tvar layoutConfig = {};\n\tvar layoutData = {};\n\n\t// Defaults\n\tvar defaults = {\n\t\tcontainerWidth: 1060,\n\t\tcontainerPadding: 10,\n\t\tboxSpacing: 10,\n\t\ttargetRowHeight: 320,\n\t\ttargetRowHeightTolerance: 0.25,\n\t\tmaxNumRows: Number.POSITIVE_INFINITY,\n\t\tforceAspectRatio: false,\n\t\tshowWidows: true,\n\t\tfullWidthBreakoutRowCadence: false,\n\t\twidowLayoutStyle: 'left'\n\t};\n\n\tvar containerPadding = {};\n\tvar boxSpacing = {};\n\n\tconfig = config || {};\n\n\t// Merge defaults and config passed in\n\tlayoutConfig = Object.assign(defaults, config);\n\n\t// Sort out padding and spacing values\n\tcontainerPadding.top = (!isNaN(parseFloat(layoutConfig.containerPadding.top))) ? layoutConfig.containerPadding.top : layoutConfig.containerPadding;\n\tcontainerPadding.right = (!isNaN(parseFloat(layoutConfig.containerPadding.right))) ? layoutConfig.containerPadding.right : layoutConfig.containerPadding;\n\tcontainerPadding.bottom = (!isNaN(parseFloat(layoutConfig.containerPadding.bottom))) ? layoutConfig.containerPadding.bottom : layoutConfig.containerPadding;\n\tcontainerPadding.left = (!isNaN(parseFloat(layoutConfig.containerPadding.left))) ? layoutConfig.containerPadding.left : layoutConfig.containerPadding;\n\tboxSpacing.horizontal = (!isNaN(parseFloat(layoutConfig.boxSpacing.horizontal))) ? layoutConfig.boxSpacing.horizontal : layoutConfig.boxSpacing;\n\tboxSpacing.vertical = (!isNaN(parseFloat(layoutConfig.boxSpacing.vertical))) ? layoutConfig.boxSpacing.vertical : layoutConfig.boxSpacing;\n\n\tlayoutConfig.containerPadding = containerPadding;\n\tlayoutConfig.boxSpacing = boxSpacing;\n\n\t// Local\n\tlayoutData._layoutItems = [];\n\tlayoutData._awakeItems = [];\n\tlayoutData._inViewportItems = [];\n\tlayoutData._leadingOrphans = [];\n\tlayoutData._trailingOrphans = [];\n\tlayoutData._containerHeight = layoutConfig.containerPadding.top;\n\tlayoutData._rows = [];\n\tlayoutData._orphans = [];\n\tlayoutConfig._widowCount = 0;\n\n\t// Convert widths and heights to aspect ratios if we need to\n\treturn computeLayout(layoutConfig, layoutData, input.map(function (item) {\n\t\tif (item.width && item.height) {\n\t\t\treturn { aspectRatio: item.width / item.height };\n\t\t} else {\n\t\t\treturn { aspectRatio: item };\n\t\t}\n\t}));\n};\n"],
  "mappings": "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",
  "names": []
}
